# 数据结构

## 目录

1. 链表
2. 栈
3. 队列





## 介绍

### 1. 链表(linked_list.py)

链表分为单向链表和双向链表 但无论何种链表需要满足如下操作：

1. 查找第i个元素 search(i)
2. 删除第i个元素 delete(i)
3. 在位置i插入一个元素A insert(A, i)

### 2. 栈(stack.py)

栈需要满足如下操作：

1. 推入 push(data)
2. 弹出 pop()

并且栈不允许栈下溢(underflow)与栈上溢(overflow)

本文件基于链表编写

### 3. 队列(queue.py)

队列需要满足如下操作：

1.  入队 enqueue(data)
2.  出队 dequeue()

并且栈不允许下溢(underflow)与上溢(overflow)

本文件基于链表编写

### 4. 哈希表(hash.py)

哈希表作为实现字典操作的一种有效的数据结构 需要满足一下操作：

1. 插入(insert)
2. 删除(delete)
3. 查找(search)

同时它还需要具有解决冲突的能力 

#### 第一种实现的是直接寻址表(HashDirectAddress) 

本例中为1000的哈希表

#### 第二种实现的是链接法哈希表(HashChained) 

本例中为哈希槽为23的哈希表

这其中包括不同的散列函数(hash_function) 

1. 除法散列法 $h(k) = k\ mod\ m$

   这种方法 对于哈希槽的数目$m$选择有一定的规则要求

   * 为了考虑key值的全部性质而不是某些位的性质 需要槽数目不是 $2^n $ 因为这样会导致key值经过散列函数后会最后n位没有变化 这样容易出现数据在某个槽内堆积的现象
   * 所以为了以上的原因建议使用不接近$2^n​$的素数

2. 乘法散列法 $h(k) = [m(kA\ mod\ 1)]$

   这种对于哈希槽的数目$m$没什么太过特殊的要求 并且对于任何$A$都适用，但是找到某些适配数据特征的$A$有很好的效果，根据Knuth的想法，$A = (\sqrt{5} - 1 ) / 2$ 是一个适合大多数情况的较为理想的值

3. 全域散列法 $h(k) = ((ak+b)\ mod\ p)\ mod\ m$

   查看了一些资料 发现构造全域散列法的方法很多 只要保证函数簇$\mathcal{H}_m$是全域的即可 这里需要牵涉到数论上的证明 需要保证任意两个不同的key值$k$, $l$经过在函数簇$\mathcal{H}_m$的任意函数映射后可以对应到$0$到$m-1$的任意值 并且两个值发生冲突的概率为$1/m$

#### 第三种实现的是开放寻址哈希表(HashOpenAddress)

有一个很有意思的小贴士：如果哈希表中一定需要删除某项时 不建议使用开放寻址法解决冲突

但为了满足哈希表的功能完整性 这一部分也被加入其中



#### 第四种实现的是完全散列表(HashPerfect)



