# 数据结构

## 目录

1. 链表
2. 栈
3. 队列
4. 堆



## 介绍

### 1. 链表(linked_list.py)

链表分为单向链表和双向链表 但无论何种链表需要满足如下操作：

1. 查找第i个元素 search(i)
2. 删除第i个元素 delete(i)
3. 在位置i插入一个元素A insert(A, i)

### 2. 栈(stack.py)

栈需要满足如下操作：

1. 推入 push(data)
2. 弹出 pop()

并且栈不允许栈下溢(underflow)与栈上溢(overflow)

本文件基于链表编写

### 3. 队列(queue.py)

队列需要满足如下操作：

1.  入队 enqueue(data)
2.  出队 dequeue()

并且栈不允许下溢(underflow)与上溢(overflow)

本文件基于链表编写

### 4. 哈希表(hash.py)

哈希表作为实现字典操作的一种有效的数据结构 需要满足一下操作：

1. 插入(insert)
2. 删除(delete)
3. 查找(search)

同时它还需要具有解决冲突的能力 

#### 第一种实现的是直接寻址表(HashDirectAddress) 

本例中为1000的哈希表

#### 第二种实现的是链接法哈希表(HashChained) 

本例中为哈希槽为23的哈希表

这其中包括不同的散列函数(hash_function) 

1. 除法散列法 $h(k) = k\ mod\ m$

   这种方法 对于哈希槽的数目$m$选择有一定的规则要求

   * 为了考虑key值的全部性质而不是某些位的性质 需要槽数目不是 $2^n $ 因为这样会导致key值经过散列函数后会最后n位没有变化 这样容易出现数据在某个槽内堆积的现象
   * 所以为了以上的原因建议使用不接近$2^n​$的素数

2. 乘法散列法 $h(k) = [m(kA\ mod\ 1)]$

   这种对于哈希槽的数目$m$没什么太过特殊的要求 并且对于任何$A$都适用，但是找到某些适配数据特征的$A$有很好的效果，根据Knuth的想法，$A = (\sqrt{5} - 1 ) / 2$ 是一个适合大多数情况的较为理想的值

3. 全域散列法 $h(k) = ((ak+b)\ mod\ p)\ mod\ m$

   查看了一些资料 发现构造全域散列法的方法很多 只要保证函数簇$\mathcal{H}_m$是全域的即可 这里需要牵涉到数论上的证明 需要保证任意两个不同的key值$k$, $l$经过在函数簇$\mathcal{H}_m$的任意函数映射后可以对应到$0$到$m-1$的任意值 并且两个值发生冲突的概率为$1/m$

#### 第三种实现的是开放寻址哈希表(HashOpenAddress)

有一个很有意思的小贴士：如果哈希表中一定需要删除某项时 不建议使用开放寻址法解决冲突

实际操作起来 不仅需要不同的标志位区分”未填充“与“已删除”，在不同操作的寻找也变得完全不同 而且在填装大部分槽后 查找复杂度比预期高很多

本例中为哈希槽m为$529(23\times23)$的哈希表 哈希表没有删除功能 

其中散列函数采用较为方便实现的乘法散列表，但是需要讨论开放寻址法的探查方法：

1. 线性探查

   $h'(k) = [m(kA\ mod\ 1)]$

   $h(k, i) = (h'(k) + i)\ mod\ m$

   这个由于其余变量所以也没有任何限制 但是由于一次群集的问题 导致随着占用空间变大 平均寻找时间也会越来越大 影响整体性能

2. 二次探查

   $h'(k) = [m(kA\ mod\ 1)]$

   $h(k, i) = (h'(k) + c_1i + c_2i^2)\ mod\ m$

   尽管这样也会导致一个轻度的群集(二次群集) 但是较线性探查会好很多 但是为了充分利用整个哈希表 对于$c_1$,  $c_2$, $m$ 有限制条件 最好保证对于从任何初始位置的哈希码值都能经过通过m次查找函数遍历整个哈希表 至少是遍历大部分  这一部分的构造方案没有给出

3. 双重散列

   $h_1(k) = [m(kA\ mod\ 1)]$

   $h_2(k) = m\ mod\ T$

   $h(k, i) = (h_1(k) + ih_2(k))\ mod\ m$

   为了能够能够查找整个散列表 需要使得$h_2(k)$所得的值和m互素

   这里给出两种方案 均能保证以上条件

   1. $m = 2^k, h_2(k) = 2N^*+1 $
   2. $m为素数， h_2(k) < m$

当然值得需要注意的是：这种方式的散列表当装载因子$\alpha$ 大于某个值 通常为(0.7-0.8)时 必须对散列表扩容 否则检索效率会很低 

#### 第四种实现的是完全散列表(HashPerfect)

这一种散列表的效率最高 在最坏情况下检索某一项可以在O(1)完成 但是值得注意的是：这种近乎完美的散列表需要在关键字是静态时使用 我们可以精心设计两层的哈希函数使得每个关键字都不会发生冲突 

当关键字集合的数目为n时，通常通过随机得到的两个全域散列函数在哈希槽$m=n^2$时出现冲突的概率小于1/2 但是如果适当调整散列函数 可以使得预期的总储存空间为O(n)

所以该散列表实际上只支持查询功能 对于插入功能需要慎重的通过枚举的方式传递到类当中 这里参考一个现成的例子 当然 为了便于操作这里m的取值为$n^2$

 值得注意的是当使用一级散列表后 对于每一种冲突都应该重新随机二级散列函数而不应该适用于一样的散列函数 否则可能会出现随机多次都不成功的情况

### 5. 堆(heap.py)

堆是一种特殊的树 主要使用在优先队列上

这里主要实现：

1. 二叉堆
2. 左倾堆
3. 斐波那契堆

其中二叉堆已经在堆排列中实现 这里以class的形式再重写一遍 这里仅给出最大堆的方案

### 6. 树(tree.py)

树结构是一种非常常见的结构 并且支持许多动态及和操作 包括

* 查找
* 插入
* 删除
* 返回最大值、最小值节点

这里主要需要实现：

1. 二叉搜索树
2. 红黑树

